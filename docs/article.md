# The Billiard Fractals

Complex systems often appear chaotic or incomprehensible, yet closer examination reveals that such complexity can frequently be reduced to a simple underlying mechanism. By systematically removing layers of emergent behavior, one can uncover a fundamental rule or equation from which the entire system originates.

![Picture](images/0.png)

While the system described in this article may appear trivial at first glance, the resulting patterns exhibit quasi-fractal behavior that can be analyzed, encoded, and even predicted through symbolic methods. The work presented here was developed independently through direct observation, rather than derived from prior literature.

A useful way to motivate this exploration is by analogy with a common physical phenomenon - wave interference. Consider waves on the surface of a river: a wavefront moves toward the shore, reflects, and overlaps with itself. Do these reflections contain an underlying order? Is it possible to extract structure from the interference?

To investigate this, we simplify the system. Rather than modeling the full wave, we consider only the motion vector - essentially, a ray. We also smooth the “shoreline” and discretize the environment into a rectangular grid. From this setup emerges the core construction of this article.

<details><summary>:)</summary>

---

The example of waves on the surface of a river serves as a real, intuitive starting point - an accessible physical system that demonstrates how simple rules, such as reflection and interference, can produce complex behavior. It illustrates the central idea: that what appears chaotic often emerges from deterministic structure.

The initial motivation was driven by the conviction that apparent disorder is not randomness, but the result of unresolved or hidden structure. Any system that seems chaotic is governed by rules - its complexity a consequence of perspective, not unpredictability.

To explore this further, attention turned to constructing the simplest possible system that could look chaotic yet remain fully deterministic.

One such system involved a sine wave originating from the corner of a rectangle and reflecting off its boundaries. The nonlinearity of the sine function causes it to intersect itself in complex and unintuitive ways. However, due to limited tools available at the time, the model was simplified even further.

Instead of a sine wave, a straight line was used. The line was made periodic (dashed), and the system was designed to be reproducible using only a pencil and a sheet of graph paper. Despite its simplicity, this construction revealed intricate and structured patterns-forming the foundation of what would later be described as the “billiard fractals.”

---

</details>

## Visualizing the Billiard Algorithm

The following sequence illustrates the core mechanism of the discrete billiard system:

![Picture](images/1.png)

An animated version:

![Picture](images/2.gif)

Output pattern:

![Picture](images/pettern0.png)

A selection of patterns generated from rectangles with various dimensions:

| | | | |
|---|---|---|---|
| <img src="images/pettern1.png"> | <img src="images/pettern2.png"> | <img src="images/pettern3.png"> | <img src="images/pettern4.png"> |
| <img src="images/pettern5.png"> | <img src="images/pettern6.png"> | <img src="images/pettern7.png"> | <img src="images/pettern8.png"> |
| <img src="images/pettern9.png"> | <img src="images/pettern10.png"> | <img src="images/pettern11.png"> | <img src="images/pettern12.png"> |

[JavaScript implementation of this algorithm](https://xcont.com/pattern.html)  
[`pattern.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/pattern.js) - source code

---

## Fibonacci Numbers and Pattern Refinement

The patterns generated by this system exhibit fractal structure: they are self-similar across scales, recursive in construction, and can be compressed symbolically. As the rectangle dimensions increase following the Fibonacci sequence, the patterns reveal increasingly detailed versions of the same underlying structure.

This refinement process is simple: given rectangle dimensions `(m, n)`, new dimensions are generated by Fibonacci summation. For example, starting with 8×13:

- 13 + 8 → 21 → becomes 13×21
- Then 21 + 13 → 34 → becomes 21×34, and so on

Each step increases resolution while preserving the underlying structure.

| 8×13 | 13×21 | 21×34 | 34×55 | 55×89 |
|------|-------|--------|--------|--------|
| ![8x13](images/8x13.png) | ![13x21](images/13x21.png) | ![21x34](images/21x34.png) | ![34x55](images/34x55.png) | ![55x89](images/55x89.png) |

<details><summary>233×377 preview comparison</summary>

---  

The article’s header image corresponds to the 233×377 pattern. Its structure can be directly compared with the earlier 13×21 case.  

---

</details>

When constructing these patterns using Fibonacci-based dimensions, we are effectively approximating a rectangle with side lengths in the golden ratio - that is, a ratio approaching (1 : φ). With each step, the approximation improves, and the pattern gains additional structure and resolution.

Although the overall structure of the pattern remains consistent during Fibonacci-based refinement, certain symmetries within the pattern depend on the parity of the rectangle's side lengths. Specifically, when both the width and height are odd integers, the resulting pattern exhibits clear diagonal, horizontal, and vertical symmetry. This occurs because the billiard path, under these conditions, terminates in the corner diagonally opposite from its starting point. In contrast, when one or both sides are even, the path terminates elsewhere, and the resulting pattern loses this precise symmetry - although the underlying recursive structure remains unchanged.

---

## Boundary Analysis and Recursive Symmetry

To understand why the structure persists under Fibonacci expansion, consider cutting a square from the pattern. The boundary behavior reveals that the path (i.e., the “billiard ball”) always returns to its entry point:

![Square reflection](images/2.png)

Moreover, the path always (except for diagonal cases) crosses an even number of cells. This ensures that the pattern remains consistent across such subdivisions.

![Trajectory loop](images/3.png)

By recursively separating square regions from the larger pattern, the symbolic seed of the system can be exposed:

![Recursive breakdown](images/4.png)

---

## Binary Representation and Symbolic Extraction

The path traced by the billiard ball through the grid can be encoded as a binary sequence. As the ball moves from cell to cell, its internal state alternates according to a fixed rule. We can label these alternating states with binary values - for example, assigning 0 to one state and 1 to the other. This produces a binary field that can be visualized directly.

For example:

![Dashed path](images/pattern34x55.png)  
![Binary encoded](images/pattern34x55_bin.png)

The top row of the binary field can be viewed as a symbolic boundary - a compact representation of the billiard system's behavior along a single edge. By studying the structure of the full 2D pattern and recursively extracting square sections from it, we arrive at symbolic generation rules. These rules allow us to reconstruct the boundary sequences using only binary operations.

Two core recursive generators are presented below:

```js
function invers(array) {
	var temp = [];
	for (let i = 0; i < array.length; i++)
		temp[i] = array[i] === 0 ? 1 : 0;
	return temp;
}

function revers(array, s) {
	var temp = [];
	for (let i = 0; i < s; i++)
		temp[i] = array[array.length - i - 1];
	return temp;
}

function seqence(fn, fn1) {
	if (fn1 === 3) return [1];
	fn1 = fn - fn1;
	fn = fn - fn1;
	var array = seqence(fn, fn1);
	var a0 = invers(array);
	var a1 = (fn1 % 2 === 0) ? [1] : [];
	var a2 = revers(array, Math.floor((fn - fn1) / 2));
	return a0.concat(a1, a2);
}

function seqenceFibonacci(iterations) {
	let f0a = [0];
	let f1a = [0];
	for (let i = 0; i < iterations; i++) {
		let f0 = f0a.length;
		let a2 = revers(f1a, f0);
		if (f1a.length % 2 === 0) a2[0] ^= 1;
		f0a = f1a;
		f1a = f1a.concat(a2);
	}
	let array = [];
	for (let i = 0; i < Math.floor(f1a.length / 2); i++)
		array[i] = f1a[i * 2];
	return array;
}
```

These constructions reproduce the symbolic edges of Fibonacci-based patterns and can be interpreted as recursive encoding schemes derived directly from the observed geometry.

<details><summary>Toward Generalization</summary>

---

While the above generators are constructed specifically for Fibonacci-sized rectangles, preliminary experiments suggest that similar structures may emerge for other co-prime pairs. These systems may obey different symbolic transformation rules, but exhibit comparable recursive or compressible traits. A formal generalization of these behaviors remains an open area of exploration.

---

</details>

One of the central challenges that motivated the progression from the original 2013 construction to the deeper analysis in 2019 was the question of irrational proportions: what happens when the rectangle’s side lengths form a truly irrational ratio, such as (1 : φ), rather than an integer-based approximation like 13 : 21?

While recursive generators such as `seqence(fn, fn1)` accurately reproduced the symbolic boundary sequences for Fibonacci-based rectangles, they were inherently tied to integer dimensions. The challenge was clear: how can one generate the same structures when no exact grid alignment is possible - when the trajectory no longer closes?

This question defines the next stage of the investigation. To answer it, we will analyze the boundary sequences themselves - the so-called *fractal sequences* - and show how they encode the entire 2D pattern. We will show that these sequences - far from being edge artifacts - contain enough information to deterministically reconstruct the entire 2D pattern. This finding enables a powerful dimensional reduction: the entire billiard system can be expressed as a 1D sequence.

---

## Binary Billiards

We now shift from the dashed-line visualization to a binary representation. Instead of drawing the trajectory, we color the cells the ball passes through, alternating black (0) and white (1) with each step.

Given a rectangle with side lengths <img src="images/M.svg" alt="$M$"> and <img src="images/N.svg" alt="$N$">, the ball is launched from a corner and follows diagonal motion, reflecting off the walls. Each step alternates the internal binary state.

![Trajectory](images/5.png)

![Resulting pattern (coprime)](images/6.png)

The reflection rule causes the pattern to shift by one cell after each bounce. This alternation creates a consistent visual structure.

![Binary fill](images/7.png)

![Reflection rule](images/8.png)

When <img src="images/M.svg" alt="$M$"> and <img src="images/N.svg" alt="$N$"> are coprime, the trajectory visits every cell exactly once:

![Full coverage](images/9.png)

[JavaScript implementation](https://xcont.com/binarypattern/)  
[`binarypattern.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/binnarypattern.js)

If the dimensions share a common divisor (<img src="images/gcd(M,N)1.svg" alt="$gcd(M, N) > 1$">), the trajectory terminates at a corner before filling all cells:

![Terminating early](images/10.png)

In this case, the system is equivalent to a billiard in a reduced rectangle with dimensions (<img src="images/frac{M}{GCD}.svg" alt="$\frac{M}{GCD}$">, <img src="images/frac{N}{GCD}.svg" alt="$\frac{N}{GCD}$">):

![Reduced case](images/11.png)

---

### Boundary Behavior and Symmetry

In the coprime case, the ball crosses every row and column. Notably, each pass between the top and left walls consists of an **even** number of steps.

![Even passes](images/12.png)  
![Even passes 2](images/13.png)

From this, we can observe a critical symmetry: the **left column** contains the inverted bits of the **top row**, excluding the initial bit.

![Boundary inversion](images/14.png)

Furthermore, every second bit (<img src="images/2_{n-1}.svg" alt="$M$">) in the top sequence is the inverted version of its neighbor (<img src="images/2_{n}.svg" alt="$2_{n}$">). Therefore, we can discard every second bit and retain full pattern information:

![Halved sequence](images/15.png)

For example, with dimensions <img src="images/M21N13.svg" alt="$M=21, N=13$">, the resulting sequence is: 1010010110

This sequence is **unique** for every coprime pair <img src="images/MN.svg" alt="$(M, N)$">. It encodes all necessary information about the pattern.

---

### Sequence Interpretation

The trajectory between two reflections from the upper wall is always <img src="images/2N.svg" alt="$2N$"> cells long. Each such pass begins with a black cell (bit = 0) and ends with a white cell (bit = 1):

![Reflection path](images/16.png)

More formally:  
- A bit of `1` indicates that the ball arrived from a reflection off the **right wall**
- A bit of `0` indicates it came from the **left wall**

This mapping gives the sequence its meaning. In the diagram below, the trajectory is colored black when moving right and white when moving left:

![Direction-colored trajectory](images/17.png)

<details><summary>Encoding Rational Division via Billiards</summary>

---

A curious side effect of the billiard construction is that it naturally encodes binary division of two numbers. Specifically, by tracking the direction of the billiard ball’s movement at each wall collision, and sampling this information at exponentially increasing intervals, one can extract the binary digits of a rational fraction.

Let the billiard table have side lengths <img src="images/M.svg" alt="$M$"> and <img src="images/N.svg" alt="$N$">, and let the ball bounce between corners. At each collision with the top or bottom wall:

If the ball is moving to the right, record a 0

If moving to the left, record a 1

Then, at every <img src="images/2_n.svg" alt="$2^n$">-th collision (i.e., 1st, 2nd, 4th, 8th, …), we record the state.

Example: for a table of size <img src="images/M21N13.svg" alt="$M=21, N=13$">, we obtain:

![Picture](images/billiard_division.png)

```
1st  (bottom, →): 0  
2nd  (top, ←):    1  
4th  (top, →):    0  
8th  (top, →):    0  
16th (top, ←):    1  
32nd (top, ←):    1  
...
```

This produces the binary expansion:

0.1001111001111001111…
Which is precisely the binary representation of <img src="images/13frac21.svg" alt="$\frac{13}{21}$">.

---

</details>

---

### Reconstruction from the Sequence

The full billiard pattern can be reconstructed from this single boundary sequence. Even extrapolation beyond the grid is possible.

Let us begin by placing the bits along the top edge of a square grid of width <img src="images/M.svg" alt="$M$">. Bits are spaced every 2 cells — these are the points where the ball would hit the upper wall:

![Bit placement](images/18.png)

Then:
- If the bit is `1`, we extend a diagonal to the **left**
- If the bit is `0`, we extend it to the **right**

![Direction rules](images/19.png)

The first bit (bit 0) is treated specially — it begins the pattern:

![Zero bit start](images/20.png)

The reconstruction produces the exact original pattern:

![Reconstructed pattern (animated)](images/21.gif)  
![Reconstructed result](images/22.png)

[JavaScript implementation](https://xcont.com/binarypattern/visualizer/)  
[`visualizer.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/visualizer.js)

---

This result shows that the 1D sequence contains **complete information** about the original 2D billiard pattern.

But we're not done.

From the surface of the river, we reduced the system to a rectangular billiard with a dashed diagonal trajectory. Then we reduced it further — to a binary field generated by alternating internal states. Now, we push the reduction one step further: we collapse the entire 2D billiard into a one-dimensional rule. A symbolic system with no geometry left — only structure.

This is where we begin to uncover the origin of these fractals.

---

## One-dimensional billiards

On the <img src="images/X.svg" alt="$X$"> number axis, we take two points: <img src="images/0.svg" alt="$0$"> and <img src="images/M.svg" alt="$M$">.

![Picture](images/23.png)

Moving from one point to another, we measure the distances <img src="images/N.svg" alt="$N$">:

![Picture](images/24.png)

We marked a point. We continue to measure the distance from this point, maintaining the direction. If we reach point <img src="images/0.svg" alt="$0$"> or <img src="images/M.svg" alt="$M$">, we change the direction:

![Picture](images/25.png)

As you can see in the pictures above, the first point shows the place where the ball touches the bottom wall of the billiard table. We are not interested in this point. We will only mark the points <img src="images/2kN.svg" alt="$2kN$"> for <img src="images/k012.svg" alt="$k=0,1,2,…$">.

How to mark these points? Let's unfold our billiard table on the <img src="images/X.svg" alt="$X$"> axis. Let's mark the points <img src="images/0M2M3M.svg" alt="$0, M, 2M, 3M,…$">. Now, having reached point <img src="images/M.svg" alt="$M$">, we do not change the direction of movement, but continue moving to point <img src="images/2M.svg" alt="$2M$">.

![Picture](images/26.png)

Points that are multiples of <img src="images/M.svg" alt="$M$"> divide our axis into segments. We will conditionally mark these segments with ones and zeros (alternating). On the segments marked with zeros, the ball (in rectangular billiards) moves from left to right. On the segments marked with ones, it moves from right to left. Or more simply: the ball moves from left to right if <img src="images/Q_k0.svg" alt="$Q_k=0$">, for

<img src="images/floor{2kN}frac{M}{mod}2.svg" alt="Q_k=\lfloor \frac{2kN}{M} \rfloor \; (\textrm{mod} \; 2); \quad k=0,1,2,…$">

It is easy to see that the point at which the ball touched the upper wall of the billiard table is the remainder of dividing <img src="images/2kN.svg" alt="$2kN$"> by <img src="images/M.svg" alt="$M$">. In this case, we don't need to record the movement of the ball in the opposite direction. We take the integer part of dividing <img src="images/2kN.svg" alt="$2kN$"> by <img src="images/M.svg" alt="$M$">, if it is even — we calculate the remainder of dividing <img src="images/2kN.svg" alt="$2kN$"> by <img src="images/M.svg" alt="$M$">. We divide the resulting remainder by 2 (the distance between adjacent touch points is two cells). This gives us the indices of the array elements that correspond to rightward motion (zeros). All other entries - representing leftward trajectories - are filled with ones.

Sequence length = <img src="images/frac{M}{2}.svg" alt="$\frac{M}{2}$">.

```js
function sequence(m,n){
	var md=m/2;
	var array=[];
	for(var k=0;k<md;k++) array[k]=1;
	for(var k=0;k<md;k++) if(Math.floor(2*k*n/m)%2==0) array[((2*k*n)%m)/2]=0;
	return array;
}
```

Now we can build a binary sequence for billiards with any sides <img src="images/M.svg" alt="$M$"> and <img src="images/N.svg" alt="$N$"> (natural numbers). Some examples:
144x89 (Fibonacci numbers):
010100101101001011010110100101101001010010110101001011010100101

169x70 (Pell numbers):
010101101010010101101010010101101010100101011010101001010110101001010101010010101101010010

233x55 (odd Fibonacci numbers <img src="images/F_n.svg" alt="$F_n$"> and <img src="images/F_{n-3}.svg" alt="$F_{n-3}$">):
010010011011011001001101101100100100110110010010011011001001001101101100100110110110010010011011001001001101100100100

<details><summary>This is dope</summary>

---

Very curious graphs are obtained if you take a billiard table with width <img src="images/M.svg" alt="$M$"> and construct sequences for each <img src="images/N.svg" alt="$N$"> from <img src="images/0.svg" alt="$0$"> to <img src="images/M.svg" alt="$M$">. Then these sequences are stacked.

```js
	var array;
	for(var y=1;y<m;y++){
		array=sequence(m,y);
		for(var x=0;x<array.length;x++){
			if(array[x]==0) context.fillRect (x, y, 1, 1);
		}
	}
```

Some examples.

| M=610 | M=611 | M=612 | M=613 | M=614 |
|------|-------|--------|--------|--------|
| ![Picture](images/M610.png) | ![Picture](images/M611.png) | ![Picture](images/M612.png) | ![Picture](images/M613.png) | ![Picture](images/M614.png) |

[JavaScript implementation](http://xcont.com/binarypattern/sequences/)  
[`sequences.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/sequences.js)

---

</details>

We have sequences. How else can we visualize binary sequences? With Turtle graphics.

---

### Turtle graphics

The sequence length determines the complexity of the curve. The more irrational the ratio between M and N, the more non-periodic and fractal - like the structure becomes.

Draw a segment. Then take bits from our sequence one by one. If bit = 1 - rotate the segment relative to the previous one by <img src="images/60^{circ}.svg" alt="$60^{\circ}$"> (clockwise). If bit = 0 - rotate the segment by <img src="images/-60^{circ}.svg" alt="$-60^{\circ}$">. The beginning of the next segment is the end of the previous one.

![Picture](images/27.png)

Take two large enough Fibonacci numbers: <img src="images/F29.svg" alt="$F_{29}=514229$"> and <img src="images/F28.svg" alt="$F_{28}=317811$">. This ensures that the pattern is long enough for the fractal structure to become apparent, but still bounded enough for visualization.

We built the sequence:
0010110100101101001010010110100101101010010110100101101001010010110100101… (257114 symbols plus a zero bit).

Visualize using turtle graphics. The size of the initial segment is 1 pixels (the initial segment is in the lower right corner):

![Picture](images/28.png)

The next example is Pell numbers.
<img src="images/Pn.svg" alt="$P_n=\begin{cases}0, n=0;\\1, n=1 \\2P_{n-1}+P_{n-2}, n>1 \end{cases}$">

We take <img src="images/P16.svg" alt="$P_{16}=470832$"> and <img src="images/P15.svg" alt="$P_{15}=195025$">.

The sequence is:
00101001010110101001010101010100101011010100101010110101001010101101 (235415 symbols plus a zero bit).

The size of the initial segment is 1 pixel:

![Picture](images/29.png)

Another example is the odd Fibonacci numbers <img src="images/F_n.svg" alt="$F_n$"> and <img src="images/F_{n-3}.svg" alt="$F_{n-3}$">.
Let's take <img src="images/F28.svg" alt="$F_{28}=317811$"> and <img src="images/F25.svg" alt="$F_{25}=75025$">.
The sequence is:
00110110010010011011001001101101100100110110110010011011011001001… (158905 plus a zero bit).
Instead of the angles <img src="images/60^{circ}.svg" alt="$60^{\circ}$"> and <img src="images/-60^{circ}.svg" alt="$-60^{\circ}$">, we will use the angles <img src="images/90^{circ}.svg" alt="$90^{\circ}$"> and <img src="images/-90^{circ}.svg" alt="$-90^{\circ}$">.
The size of the initial segment is 1 pixels:

![Picture](images/30.png)

This curve is called "[Fibonacci Word Fractal](https://en.wikipedia.org/wiki/Fibonacci_word_fractal)". The Hausdorff dimension for this curve is known:

<img src="images/hausdorff.svg" alt="$D=3{\frac {\log \Phi }{\log(1+{\sqrt {2}})}}=1.6379; \quad \Phi =\frac {1+{\sqrt {5}}}{2}$">

[JavaScript implementation](https://xcont.com/binarypattern/turtle/)  
[`turtle.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/turtle.js)

---

### The problem unsolved yet.

Is it possible to draw a pattern for billiards, the sides of which are incommensurable (one of the sides is an irrational number)? At first glance, the task seems impossible. Trying to solve this problem, we will face a number of questions:

1. If the sides are incommensurable, we cannot tile the billiards with cells of the same size.
2. If the sides are incommensurable, the ball will infinitely reflect and will never get into the corner.
3. Sequences in billiards are not filled in order, but chaotically.

![Picture](images/31.gif)

The first two questions obviously have no solution. But if there were a way to fill the sequence in order, then we could, moving along the sequence from left to right, restore the pattern in the way we used above. And thus see what the pattern looks like in the upper left corner of the billiard table whose sides are incommensurable.

---

### o_O

Let's take a billiard table, the sides of which are equal to the Fibonacci numbers (this trick may not work with other numbers). Let's throw a ball into it and record the number of times the ball touches the upper wall. We'll paint the numbers white if the ball moved from right to left and black if the ball moved from left to right:

![Picture](images/32.png)

White corresponds to the number one in the sequence, black to zero. Now let's arrange the numbers in order:

![Picture](images/33.png)

We've got exactly the same sequence of ones and zeros.

21(1), 13(0), 8(1), 26(0), 5(0), 16(1), 18(0), 3(1), 24(1), 10(0), 11(1), 23(0), 2(0), 19(1), 15(0), 6(1), 27(1), 7(0), 14(1), 20(0), 1(1), 22(1), 12(0), 9(1), 25(0), 4(0), 17(1)

1(1), 2(0), 3(1), 4(0), 5(0), 6(1), 7(0), 8(1), 9(1), 10(0), 11(1), 12(0), 13(0), 14(1), 15(0), 16(1), 17(1), 18(0), 19(1), 20(0), 21(1), 22(1), 23(0), 24(1), 25(0), 26(0), 27(1)


<details><summary>For other numbers</summary>

---

The origin is the upper left corner. The <img src="images/X.svg" alt="$X$"> axis is the width of the billiard table <img src="images/M.svg" alt="$M$">. The <img src="images/Y.svg" alt="$Y$"> axis is the height of the billiard table <img src="images/N.svg" alt="$N$">. The numbers for which the sequences match are marked with white dots:

![Picture](images/34.png)

Numbers for which the sequence is inverted:

![Picture](images/35.png)

JavaScript implementation:

![Picture](images/36.png)

The first line is the mouse coordinates, which are used as the width and height of the billiard table.
The second line is the first 100 bits of the sequence obtained through the remainders of the division.
The third line is the first 100 bits of the sequence obtained through the parity of the integer part.

Black color - Visualization of the first sequence using Turtle graphics.
Purple - visualization of the second sequence.

[JavaScript implementation](http://xcont.com/binarypattern/mouseturtle/)  
[`turtle_dynamic.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/turtle_dynamic.js)

---

</details>

In fact, in some cases, we do not need to take the remainder from the division. For Fibonacci numbers, it is enough to check the parity of the integer part of the division of <img src="images/2kN.svg" alt="$2kN$"> by <img src="images/M.svg" alt="$M$">:

<img src="images/floor{2kN}frac{M}{mod}2.svg" alt="$Q_k=\lfloor \frac{2kN}{M} \rfloor \; (\textrm{mod} \; 2); \quad k=0,1,2,…$">

In the numerator we have <img src="images/F_n.svg" alt="$F_{n}$">. In the denominator - <img src="images/F_{n+1}.svg" alt="$F_{n+1}$">.

As is known:
<img src="images/frac{1}{Phi}.svg" alt="$\lim_{n\to\infty} \frac{F_n}{F_{n+1}}= \frac{1}{\Phi}$">

This gives us a bridge: rational billiards (<img src="images/F_n.svg" alt="$F_{n}$">, <img src="images/F_{n+1}.svg" alt="$F_{n+1}$">) converge toward an irrational limit - <img src="images/Phi.svg" alt="$\Phi$"> - allowing us to define an infinite symbolic sequence.

<img src="images/Phi.svg" alt="$\Phi$"> is the Golden Ratio. An irrational number. Now we can write our formula as:

<img src="images/frac{2k}{Phi}.svg" alt="$Q_k=\lfloor \frac{2k}{\Phi} \rfloor \; (\textrm{mod} \; 2); \quad k=0,1,2,…$">

We have obtained a formula with which we can fill in the sequence for a billiard table, the width of which is <img src="images/Phi.svg" alt="$\Phi$"> and the height is <img src="images/1.svg" alt="$\1$">. The length of the sequence = <img src="images/infinity.svg" alt="$\infty$">, but we can restore part of the pattern by moving from left to right along the sequence and looking into the upper left corner of the billiard table. It remains to figure out how to calculate <img src="images/Phi.svg" alt="$\Phi$">

One divided by the golden ratio can be rewritten as:

<img src="images/frac{1}{Phi}equal.svg" alt="$\frac{1}{\Phi}=\frac {-1+{\sqrt {5}}}{2}$">

We can get rid of the two:

<img src="images/frac{2k}{Phi}equal.svg" alt="$\frac{2k}{\Phi}=\frac {2k(-1+{\sqrt {5}})}{2}=k\sqrt{5}-k$">

Our formula takes the form:

<img src="images/sqrt{5}.svg" alt="$Q_k=\lfloor k\sqrt{5}-k \rfloor \; (\textrm{mod} \; 2); \quad k=0,1,2,…$">

Now we can draw part of the billiard pattern with sides <img src="images/1.svg" alt="$\1$"> and <img src="images/Phi.svg" alt="$\Phi$">:

![Picture](images/37.png)

If we do not subtract <img src="images/k.svg" alt="$k$"> each time, then every second bit in the sequence is inverted. We get the general formula:

<img src="images/floor(kx)mod2.svg" alt="$Q_k=\lfloor k\sqrt{x} \rfloor \; (\textrm{mod} \; 2); \quad k=0,1,2,…$">:

Let's build a sequence for $k\sqrt{2}$

```js
var x=2;
var q=[];
for(var k=0;k<256000;k++) q[k]=Math.floor(k*Math.sqrt(x))%2;
```

The first few bits of the sequence ([A083035](http://oeis.org/A083035)):
01001101100100110011001101100100110110011001001101100100110110…

Angles are <img src="images/90^{circ}.svg" alt="$90^{\circ}$"> and <img src="images/-90^{circ}.svg" alt="$-90^{\circ}$">. The size of the initial segment is 5 pixels:

![Picture](images/38.png)

<details><summary>This is interesting</summary>

---

From this curve, we can reconstruct the "billiard pattern" and see what is around the curve:

![Picture](images/39.png)

It would be interesting to choose <img src="images/M.svg" alt="$M$"> and <img src="images/N.svg" alt="$N$"> for this pattern.

---

</details>

<details><summary>And this</summary>

---

Number of segments in the repeating part of the curve = <img src="images/Pn(2).svg" alt="$P_n$"> (Pell numbers: 0, 1, 2, 5, 12, 29, 70, 169, 408, 985, 2378, … ).

![Picture](images/40.png)

<img src="images/sqrt{2}equal.svg" alt="$\sqrt{2} = \lim_{n\to\infty} \tfrac{P_{n-1}+P_n}{P_n}$">

---

</details>

Someone may doubt that the parity of the integer part of <img src="images/ksqrt2.svg" alt="$k\sqrt{2}$"> gives a fractal sequence. Let's visualize part of this sequence with the visualizer described earlier:

![Picture](images/41.png)

For clarity, I colored the longest curve in the resulting pattern:

![Picture](images/42.png)

This curve has a name - "Fibonacci word fractal".

Thus, by gradually reducing billiard geometry through symbolic encodings, we arrive at a powerful realization: even irrational systems, which defy spatial tiling and corner reflection, can still produce deterministic, fractal structure — using only integer math.

---

## Filling the Fractal: From Symbolic Structure to Visual Density

In the previous sections, we showed how symbolic sequences can generate complex boundary structures in discrete 2D space. All of these patterns - whether generated by rational billiards or floor-based symbolic systems - form enclosed regions.
Some of these regions close against the boundaries of the rectangle, while others are fully self-contained, looping within the grid. In either case, the resulting trajectories always define fully enclosed cells.

Consider the following example:

A binary sequence generated by the floor function:
<img src="images/floor(nsqrt2).svg" alt="$Q_n=\lfloor n\sqrt{2} \rfloor \; (\textrm{mod} \; 2); \quad n=0,1,2,…$">

0100110110010011001001101100

Using [the visualizer](https://xcont.com/binarypattern/visualizer/) in diagonal mode, we generate a familiar fractal boundary.

![Picture](images/0100110110010011001001101100.png)

However, switching to horizontal–vertical visualization, we invert every even-indexed bit and plot dashed lines accordingly. For bits with value 0, the lines are offset by one unit.

Vertical lines:

![Picture](images/vert.png)

Horizontal lines:

![Picture](images/hor.png)

Merged:

![Picture](images/hitomezashi.png)

This technique resembles **Hitomezashi stitching**, a traditional Japanese method of generating textile patterns. While historically used to create decorative designs, this form of boundary generation bears striking similarity to the symbolic outlines produced in our system.

However, **Hitomezashi does not solve the filling problem**. It provides only the **skeleton** — the structure of edges — but no mechanism for interior construction.

![Picture](images/hitomezashi_filled.png)

---

## A Symbolic Filling Algorithm

To solve this, we developed a symbolic method to **automatically fill** the interior regions — using only the original sequence. No region detection, no geometry, no search algorithms.

The method works as follows:

Construct a cumulative array a[n], based on the bitwise value of the fractal sequence:

<img src="images/ansequence.svg" alt="$Q_n=\lfloor n\sqrt{x} \rfloor \; (\textrm{mod} \; 2); \quad n=0,1,2,…\\ a_n=\begin{cases}a_{n-1}+1, Q_n=1;\\a_{n-1}-1, Q_n=0\end{cases}$">

In code:

```js
var a = [0];
for (var i = 1; i < size; i++) {
	if (Math.floor(i * Math.sqrt(2)) % 2 == 1)
		a[i] = a[i - 1] + 1;
	else
		a[i] = a[i - 1] - 1;
}
```

Then, for each cell (x, y), compute:

```js
q = (a[x] + a[y] + 512) % 4;
if (q === 0 || q === 1)
	context.fillRect(x, y, 1, 1);
```

The result is a filled pattern — not derived from pixel analysis or region marking, but **emerging directly from the same symbolic system** that generated the boundaries.

### Full Algorithm

```js
var a=[0];
for(var i=1;i<size;i++){
	if(Math.floor(i*Math.sqrt(2))%2==1)
		a[i]=a[i-1]+1;
	else
		a[i]=a[i-1]-1;
}
for(var x=0;x<size;x++){
	for(var y=0;y<size;y++){
		q=(a[x]+a[y]+512)%4;
		if(q==0 || q==1) context.fillRect(x, y, 1, 1);
	}
}
```

## Examples

Fractal fill based on:

<img src="images/sqrt2.svg" alt="$Q_n=\lfloor n\sqrt{2} \rfloor \; (\textrm{mod} \; 2); \quad n=0,1,2,…$">

![Picture](images/sqrt2.png)

<details><summary>Gif</summary>
	
![Picture](images/sqrt2.gif)

</details>

<img src="images/sqrt5plus1.svg" alt="$Q_n=\lfloor n(\sqrt{5}+1) \rfloor \; (\textrm{mod} \; 2); \quad n=0,1,2,…$">

(Fibonacci-based)

![Picture](images/sqrt5plus1.png)

<details><summary>Gif</summary>
	
![Picture](images/sqrt5plus1.gif)

</details>

### Interactive

[Visualizer — Fractal Fill from Irrationals](https://xcont.com/binarypattern/fractal.html)  
[`fractal.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/fractal.js)

[Dynamic Visualization — Using Rational Approximations](https://xcont.com/binarypattern/fractal_dynamic.html)  
[`fractal_dynamic.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/fractal_dynamic.js)

---

<details><summary>Perfect Shuffle Comparison (Speculative)</summary>

---

### Pattern Matching via Perfect Shuffles

We can compare fractal sequences from floor-based systems with sequences produced by a [perfect shuffle](https://github.com/xcontcom/perfect-shuffle) function.

Here's our shuffle logic:

```js
function shuffle(array, shiftAmount) {
	let len = array.length;
	let shuffled = new Array(len * 2);
	for (let i = 0; i < len; i++) {
		shuffled[2 * i] = array[(i + shiftAmount) % len];
		shuffled[2 * i + 1] = array[i];
	}
	return shuffled;
}
```

We start with a base array:

```js
let array1 = [1, 0];
for (let i = 0; i < 15; i++) {
	array1 = shuffle(array1, (y + 45) * 128);
}
```

And compare it with this floor-based sequence:

```js
let array2 = [];
for (let i = 0; i < sizexy; i++) {
	array2[i] = Math.floor(i * (y + 45) / 128) % 2;
}
```

Both arrays are then visualized using our bit-pattern analysis:

```js
for (let y = 0; y < sizexy; y++) {
	// generate array1 or array2

	let digit;
	let bits = [];
	for (let i = 0; i < len; i++) {
		digit = 0;
		for (let j = 0; j < bitLength; j++) {
			digit |= array[i + j] << (bitLength - 1 - j);
		}
		if (!bits.includes(digit)) {
			bits.push(digit);
		}
	}
	for (let i = 0; i < bits.length; i++) {
		context.fillRect(bits[i] * size, y * size, size, size);
	}
}
```

Here are the results:

Perfect shuffle:

![Picture](images/45_128_shuffle.png)

Floor-based sequence:

![Picture](images/45_128_floor.png)

The two patterns are visually identical.

This suggests that in some cases, perfect shuffle systems and irrational-floor systems may produce the same fractal binary sequences — or at least structurally equivalent ones.

We don’t yet have a formal proof or a unifying theory. But the match is too precise to ignore.

More analysis is needed to determine whether these overlaps are coincidence, mathematical identity, or reflections of a deeper shared structure. For now, we consider this a visually compelling anomaly — worth future investigation.

---

</details>

---

## Nonlinear Functions and Symbolic Surface Slicing

### Symbolic Rotation and the Circle Representation

The binary sequence generated by

<img src="images/part4_florksqrt2mod2.svg" alt="$\left\lfloor k \sqrt{2} \right\rfloor \bmod 2$">

can be interpreted geometrically as a **rotation on the unit circle**. At each step <img src="images/part4_k.svg" alt="$k$">, we rotate by an irrational angle (e.g., <img src="images/part4_sqrt2.svg" alt="$\sqrt{2}$">) and assign a 0 or 1 depending on which half of the circle the point lands in.

An alternative but mathematically equivalent formulation is:

<img src="images/part4_sinpiksqrt2more.svg" alt="$\sin\left( \pi k \sqrt{2} \right) > 0$">

The sine function is positive in one half of the circle and negative in the other - effectively producing the same binary threshold.

![Picture](images/sin.png)

This circular diagram shows the orbit of

<img src="images/part4_ksqrt2mod1.svg" alt="$k \sqrt{2} \bmod 1$">

projected onto the unit circle. The points rotate continuously and never repeat. Each crossing of the horizontal axis (i.e., sign change of <img src="images/part4_sinpiksqrt2.svg" alt="$\sin\left( \pi k \sqrt{2} \right)$">) causes a binary switch. The result is a **Sturmian sequence** - a symbolic encoding of irrational rotation - visualized as a point traveling clockwise and recording its hemisphere.

Interestingly, even a sequence like

<img src="images/part4_sinkmore.svg" alt="$\sin\left( k \right) > 0$">

generates a similarly complex structure. Though the function seems simple, stepping by exactly 1 radian per iteration is irrational with respect to the sine wave’s natural period of <img src="images/part4_2pi.svg" alt="$2 \pi$">. Thus:

<img src="images/part4_longarrow.svg" alt="$\sin(k) > 0 \quad \Longleftrightarrow \quad \left\lfloor \frac{k}{\pi} \right\rfloor \bmod 2$">

Which means: **irrational step size alone is enough to create symbolic fractals**. It’s not the shape of the function - it’s the incommensurability that matters.

### Geometric Interpretation of Linear Discretization

We begin with a geometric interpretation of the function

<img src="images/part4_florksqrt2mod2.svg" alt="$\left\lfloor k \sqrt{2} \right\rfloor \bmod 2$">

This can be visualized as a straight line <img src="images/part4_yksqrt2.svg" alt="$y=k \sqrt{2}$"> traversing a periodic 2D space where the <img src="images/part4_y.svg" alt="$y$">-axis alternates between bands labeled 0 and 1. The value of the function at each step depends on the integer part of <img src="images/ksqrt2.svg" alt="$k\sqrt{2}$">, determining whether the line intersects an even or odd band.

![Picture](images/linear_function.png)

Alternatively, we may interpret the system as a function <img src="images/part4_yx.svg" alt="$y=x$"> with <img src="images/part4_sqrt2.svg" alt="$\sqrt{2}$"> acting as a discretization step along the vertical axis. This perspective reduces the behavior of the original billiard system to a symbolic sampling of a continuous linear function.

Both

<img src="images/part4_both.svg" alt="$\left\lfloor k \sqrt{2} \right\rfloor \bmod 2 \quad \text{and} \quad \sin\left( \pi k \sqrt{2} \right) > 0$">

serve as symbolic discretization methods - one yielding binary values via integer floor division, the other through sign thresholding on a continuous sinusoid.

### Transition to Quadratic Functions

Having reduced the system to a linear function and its discretization, we now explore the effects of replacing the base function <img src="images/part4_yx.svg" alt="$y=x$"> with a nonlinear alternative.

Linear rotation yields symbolic Sturmian sequences. What happens if we increase the curvature? Quadratic growth is the simplest next step.

We now substitute the linear function with:

<img src="images/part4_yxx.svg" alt="$y = x^2$">

We construct the new sequence using:

<img src="images/part4_qx_xx.svg" alt="$Q_x=\lfloor x^2\sqrt{2} \rfloor \; (\textrm{mod} \; 2); \quad x=0,1,2,…$">

```js
q[x] = Math.floor(x * x * Math.sqrt(2)) % 2;
```

This substitution shifts us from uniform linear growth to a system governed by accelerating curvature, producing richer and more complex symbolic behavior.

Visualizing this sequence with the Symbolic Filling Algorithm yields a disordered pattern.

![Picture](images/sqrt2surface.png)

<details><summary>Gif</summary>
	
![Picture](images/sqrt2surface.gif)

</details>

Similarly, applying Turtle graphics results in "chaotic" outputs

![Picture](images/turtle.png)

suggesting that the underlying symbolic dynamics differ significantly from the linear case. This observation motivated us to try a simpler visual encoding.

This prompts a reconsideration of visualization methods. Rather than relying on complex binary sequence encodings (e.g., symbolic filling or turtle graphics), we adopt a simpler approach:

1. Place the first k elements of the sequence q[x] in the initial row.
2. For each subsequent row along the y-axis, use q[x+ky].
3. The result is a striking array of structured, interference-like patterns.

This reveals that a seemingly chaotic 1D sequence can exhibit coherent spatial behavior when unfolded along two dimensions. Generalizing this, we rewrite the indexing expression as:

```js
q[x] = Math.floor((x + k * y) ** 2 * Math.sqrt(2)) % 2;
```

Expanding the square:

<img src="images/part4_xky.svg" alt="$(x + k y)^2 = x^2 + 2kxy + k^2 y^2$">

This quadratic form suggests a symbolic sampling of a 3D curved surface. We abstract this into a general expression:

<img src="images/part4_general_formula.svg" alt="$z = a \left( x^2 + bxy + c y^2 \right)^d$">

Here:

* <img src="images/a.svg" alt="$a$"> controls vertical scaling (the *discretization frequency*),
* <img src="images/b.svg" alt="$b$"> introduces diagonal shear,
* <img src="images/c.svg" alt="$c$"> modulates stretching along the <img src="images/part4_y.svg" alt="$y$">-axis,
* and <img src="images/d.svg" alt="$d$"> introduces curvature nonlinearity.

For example, setting <img src="images/b0c1d1.svg" alt="$b=0,c=1,d=1$"> yields:

<img src="images/part4_paraboloid.svg" alt="$z = a \left( x^2 + y^2 \right)$">

an **elliptical paraboloid**, a classic bowl-shaped surface.

![Picture](images/paraboloid.png)

We then visualize both:

<img src="images/part4_zsqrt2.svg" alt="$\left\lfloor z \sqrt{2} \right\rfloor \bmod 2$">

<img src="images/part4_sinz.svg" alt="$\sin\left( \pi z \sqrt{2} \right)$">

...using this surface. Despite differing in output (binary vs. continuous), both render structurally equivalent patterns: the sine version produces smooth grayscale textures, while the floor function yields crisp binary segmentation. In either case, the resulting 2D images exhibit radial, interference-like motifs - strongly reminiscent of diffraction or holographic patterns.

| binary | continuous |
|---|---|
| <img src="images/hol1div400bin.png"> | <img src="images/hol1div400con.png"> |

The sine-based rendering reveals finer gradients and smoother interference zones, but the underlying symbolic structure is identical to the binary version.

---

### Holographic Analogy
In classical holography, a point source emits nested spherical wavefronts. When these are sliced by a flat recording plane, the amplitude at each (x, y) position encodes a continuous interference pattern. The spacing between wavefronts defines the wavelength - effectively a discretization step in the z-direction.

Our system inverts this paradigm: instead of slicing nested curved shells with a flat surface, we intersect a single curved surface with stacked, evenly spaced binary planes - symbolic layers representing a plane wavefront. Each (x, y) coordinate samples which symbolic layer the surface intersects, producing a binary (or thresholded) value.

While the components differ - continuous vs symbolic, curved emitter vs curved surface - the underlying mechanism is the same: a curved geometry intersected by layered structure, producing interference-like textures from simple spatial rules.

Despite differences in physical interpretation, both systems share a core structure: curved geometry meets layered slicing - and complexity emerges.

---

Our picture size is 400 pixels. We used <img src="images/hol_a1div400.svg" alt="$frac{1}{400}$"> for previous picture to fit the picture.

Here another pattern with <img src="images/hol_a1div200.svg" alt="$frac{1}{200}$">:

| binary | continuous |
|---|---|
| <img src="images/hol1div200bin.png"> | <img src="images/hol1div200con.png"> |

<img src="images/c.svg" alt="$c$"> modulates stretching along the <img src="images/part4_y.svg" alt="$y$">-axis

(we will use continuous patterns from now).

| <img src="images/hol_c2.svg" alt="$c=2$"> | <img src="images/hol_c02.svg" alt="$c=0.2$"> |
|---|---|
| <img src="images/hol_c2.png"> | <img src="images/hol_c02.png"> |

<img src="images/b.svg" alt="$b$"> introduces diagonal shear

| <img src="images/hol_b-15.svg" alt="$b=-1.5$"> | <img src="images/hol_b15.svg" alt="$b=1.5$"> |
|---|---|
| <img src="images/hol_b-15.png"> | <img src="images/hol_b15.png"> |

For <img src="images/hol_b0c-1d1.svg" alt="$b=0,c=-1,d=1$"> our equation becomes:

<img src="images/hol_zax2-y2.svg" alt="$z=a(x^2-y^2)$">

This is a hyperbolic paraboloid - a surface with negative Gaussian curvature:

![Picture](images/hyperbolic_paraboloid.png)

| <img src="images/hol_a1div400.svg" alt="$frac{1}{400}$"> | <img src="images/hol_a1div200.svg" alt="$frac{1}{200}$"> |
|---|---|
| <img src="images/hol_hyper_1div400.png"> | <img src="images/hol_hyper_1div200.png"> |

For <img src="images/hol_b0c1d1div5.svg" alt="$b=0, c=1, d=1/5$"> our equation becomes:

<img src="images/hol_zax2+y2d1div5.svg" alt="$z=a(x^2+y^2)^{1/5}$">

![Picture](images/maple_screen.png)

| | |
|---|---|
| <img src="images/hol_a1.svg" alt="$a=1$"> | <img src="images/hol_a10.svg" alt="$a=10$"> |
| <img src="images/hol_d1div5_a1.png"> | <img src="images/hol_d1div5_a10.png"> |
| <img src="images/hol_a100.svg" alt="$a=100$"> | <img src="images/hol_a100.svg" alt="$a=1000$"> |
| <img src="images/hol_d1div5_a100.png"> | <img src="images/hol_d1div5_a1000.png"> |

The most interesting patterns are obtained if we take a <img src="images/d.svg" alt="$d$"> that differs slightly from 1. For example, for 

<img src="images/hol_b0c1d1div101.svg" alt="$b=0, c=1, d=\frac{1}{1.01}$">

| | |
|---|---|
| <img src="images/hol_a182div58.svg" alt="$a=\frac{182}{58}$"> | <img src="images/hol_a173div165.svg" alt="$a=\frac{173}{165}$"> |
| <img src="images/hol_b0c1d101_182div58.png"> | <img src="images/hol_b0c1d101_173div165.png"> |
| <img src="images/hol_a170div109.svg" alt="$a=\frac{170}{109}$"> | <img src="images/hol_a111div70.svg" alt="$a=\frac{111}{70}$"> |
| <img src="images/hol_b0c1d101_170div109.png"> | <img src="images/hol_b0c1d101_111div70.png"> |
| <img src="images/hol_a57div178.svg" alt="$a=\frac{57}{178}$"> | <img src="images/hol_a186div119.svg" alt="$a=\frac{186}{119}$"> |
| <img src="images/hol_b0c1d101_57div178.png"> | <img src="images/hol_b0c1d101_186div119.png"> |

<img src="images/hol_b1c1d1div101.svg" alt="$b=1, c=1, d=\frac{1}{1.01}$">

The most interesting patterns are obtained if we take a <img src="images/d.svg" alt="$d$"> that differs slightly from 1. For example, for 

<img src="images/hol_b0c1d1div101.svg" alt="$b=0, c=1, d=\frac{1}{1.01}$">

| | |
|---|---|
| <img src="images/hol_a182div58.svg" alt="$a=\frac{182}{58}$"> | <img src="images/hol_a173div165.svg" alt="$a=\frac{173}{165}$"> |
| <img src="images/hol_b0c1d101_182div58.png"> | <img src="images/hol_b0c1d101_173div165.png"> |
| <img src="images/hol_a170div109.svg" alt="$a=\frac{170}{109}$"> | <img src="images/hol_a111div70.svg" alt="$a=\frac{111}{70}$"> |
| <img src="images/hol_b0c1d101_170div109.png"> | <img src="images/hol_b0c1d101_111div70.png"> |
| <img src="images/hol_a57div178.svg" alt="$a=\frac{57}{178}$"> | <img src="images/hol_a186div119.svg" alt="$a=\frac{186}{119}$"> |
| <img src="images/hol_b0c1d101_57div178.png"> | <img src="images/hol_b0c1d101_186div119.png"> |

<img src="images/hol_b1c1d1div101.svg" alt="$b=1, c=1, d=\frac{1}{1.01}$">

| | |
|---|---|
| <img src="images/hol_a174div111.svg" alt="$a=\frac{174}{111}$"> | <img src="images/hol_a50div152.svg" alt="$a=\frac{50}{152}$"> |
| <img src="images/hol_b1c1d101_174div111.png"> | <img src="images/hol_b1c1d101_50div152.png"> |

---

### Interactive

[Dynamic Visualization - static](https://xcont.com/billiard_dynamic/hologram_static/)  
[`hologram_s.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/hologram_s.js)

[Dynamic Visualization - dynamic](https://xcont.com/billiard_dynamic/hologram_dynamic/)  
[`hologram.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/hologram.js)

---

## Speculative bullshit

