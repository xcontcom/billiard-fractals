# The Billiard Fractals

Complex systems often appear chaotic or incomprehensible, yet closer examination reveals that such complexity can frequently be reduced to a simple underlying mechanism. By systematically removing layers of emergent behavior, one can uncover a fundamental rule or equation from which the entire system originates.

![Picture](images/0.png)

While the system described in this article may appear trivial at first glance, the resulting patterns exhibit quasi-fractal behavior that can be analyzed, encoded, and even predicted through symbolic methods. The work presented here was developed independently through direct observation, rather than derived from prior literature.

A useful way to motivate this exploration is by analogy with a common physical phenomenon - wave interference. Consider waves on the surface of a river: a wavefront moves toward the shore, reflects, and overlaps with itself. Do these reflections contain an underlying order? Is it possible to extract structure from the interference?

To investigate this, we simplify the system. Rather than modeling the full wave, we consider only the motion vector - essentially, a ray. We also smooth the “shoreline” and discretize the environment into a rectangular grid. From this setup emerges the core construction of this article.

<details><summary>:)</summary>

---

The example of waves on the surface of a river serves as a real, intuitive starting point - an accessible physical system that demonstrates how simple rules, such as reflection and interference, can produce complex behavior. It illustrates the central idea: that what appears chaotic often emerges from deterministic structure.

The initial motivation was driven by the conviction that apparent disorder is not randomness, but the result of unresolved or hidden structure. Any system that seems chaotic is governed by rules - its complexity a consequence of perspective, not unpredictability.

To explore this further, attention turned to constructing the simplest possible system that could look chaotic yet remain fully deterministic.

One such system involved a sine wave originating from the corner of a rectangle and reflecting off its boundaries. The nonlinearity of the sine function causes it to intersect itself in complex and unintuitive ways. However, due to limited tools available at the time, the model was simplified even further.

Instead of a sine wave, a straight line was used. The line was made periodic (dashed), and the system was designed to be reproducible using only a pencil and a sheet of graph paper. Despite its simplicity, this construction revealed intricate and structured patterns—forming the foundation of what would later be described as the “billiard fractals.”

---

</details>

## Visualizing the Billiard Algorithm

The following sequence illustrates the core mechanism of the discrete billiard system:

![Picture](images/1.png)

An animated version:

![Picture](images/2.gif)

Output pattern:

![Picture](images/pettern0.png)

A selection of patterns generated from rectangles with various dimensions:

| | | | |
|---|---|---|---|
| <img src="images/pettern1.png"> | <img src="images/pettern2.png"> | <img src="images/pettern3.png"> | <img src="images/pettern4.png"> |
| <img src="images/pettern5.png"> | <img src="images/pettern6.png"> | <img src="images/pettern7.png"> | <img src="images/pettern8.png"> |
| <img src="images/pettern9.png"> | <img src="images/pettern10.png"> | <img src="images/pettern11.png"> | <img src="images/pettern12.png"> |

[JavaScript implementation of this algorithm](https://xcont.com/pattern.html)  
[`pattern.js`](https://github.com/xcontcom/billiard-fractals/blob/main/js/pattern.js) — source code

---

## Fibonacci Numbers and Pattern Refinement

The patterns generated by this system exhibit fractal structure: they are self-similar across scales, recursive in construction, and can be compressed symbolically. As the rectangle dimensions increase following the Fibonacci sequence, the patterns reveal increasingly detailed versions of the same underlying structure.

This refinement process is simple: given rectangle dimensions `(m, n)`, new dimensions are generated by Fibonacci summation. For example, starting with 8×13:

- 13 + 8 → 21 → becomes 13×21
- Then 21 + 13 → 34 → becomes 21×34, and so on

Each step increases resolution while preserving the underlying structure.

| 8×13 | 13×21 | 21×34 | 34×55 | 55×89 |
|------|-------|--------|--------|--------|
| ![8x13](images/8x13.png) | ![13x21](images/13x21.png) | ![21x34](images/21x34.png) | ![34x55](images/34x55.png) | ![55x89](images/55x89.png) |

<details><summary>233×377 preview comparison</summary>

---  
The article’s header image corresponds to the 233×377 pattern. Its structure can be directly compared with the earlier 13×21 case, highlighting recursive properties.  
---

</details>

When constructing these patterns using Fibonacci-based dimensions, we are effectively approximating a rectangle with side lengths in the golden ratio — that is, a ratio approaching (1 : φ). With each step, the approximation improves, and the pattern gains additional structure and resolution.

However, it is important to note that while the **underlying structure** of the pattern remains consistent, the **positioning of the pattern** may shift depending on whether the Fibonacci dimensions used are even or odd indexed. This does not indicate a change in the rules or a misalignment, but rather reflects a deeper structural sensitivity to the parity of the dimensions.

A fundamental question arises here — one that persisted between the initial formulation of this system (2013) and the deeper symbolic analysis developed later (2019):  
**What happens when the rectangle's proportions are truly irrational — when the side lengths are in exact ratio (1 : φ), not just approximated by integers?**  
How do the patterns behave then? And more importantly, how can they be generated without relying on approximation?

This question leads naturally into the next stage of exploration: analyzing the boundary sequences themselves. These sequences — which we term *fractal sequences* — encode the full structure of the original billiard patterns. By studying their composition, we will develop a method to reconstruct the entire 2D pattern directly from the 1D sequence. This, in turn, sets the stage for reducing the 2D billiard system to a 1D representation — a step that allows us to extend the system to irrational configurations and eventually uncover a simple mathematical expression that generates the same fractal behavior.

---

## Boundary Analysis and Recursive Symmetry

To understand why the structure persists under Fibonacci expansion, consider cutting a square from the pattern. The boundary behavior reveals that the path (i.e., the “billiard ball”) always returns to its entry point:

![Square reflection](images/2.png)  
![Trajectory loop](images/3.png)

Additionally, the path always crosses an even number of cells. This ensures that the pattern remains consistent across such subdivisions.

By recursively separating square regions from the larger pattern, the symbolic seed of the system can be exposed:

![Recursive breakdown](images/4.png)

---

## Binary Representation and Symbolic Extraction

The path traced by the billiard ball through the grid can be encoded as a binary sequence. As the ball moves from cell to cell, its internal state alternates according to a fixed rule. We can label these alternating states with binary values — for example, assigning 0 to one state and 1 to the other. This produces a binary field that can be visualized directly.

For example:

![Dashed path](images/pattern34x55.png)  
![Binary encoded](images/pattern34x55_bin.png)

The top row of the binary field can be viewed as a symbolic boundary — a compact representation of the billiard system's behavior along a single edge. By studying the structure of the full 2D pattern and recursively extracting square sections from it, we arrive at symbolic generation rules. These rules allow us to reconstruct the boundary sequences using only binary operations.

Two core recursive generators are presented below:

```js
function invers(array) {
	var temp = [];
	for (let i = 0; i < array.length; i++)
		temp[i] = array[i] === 0 ? 1 : 0;
	return temp;
}

function revers(array, s) {
	var temp = [];
	for (let i = 0; i < s; i++)
		temp[i] = array[array.length - i - 1];
	return temp;
}

function seqence(fn, fn1) {
	if (fn1 === 3) return [1];
	fn1 = fn - fn1;
	fn = fn - fn1;
	var array = seqence(fn, fn1);
	var a0 = invers(array);
	var a1 = (fn1 % 2 === 0) ? [1] : [];
	var a2 = revers(array, Math.floor((fn - fn1) / 2));
	return a0.concat(a1, a2);
}

function seqenceFibonacci(iterations) {
	let f0a = [0];
	let f1a = [0];
	for (let i = 0; i < iterations; i++) {
		let f0 = f0a.length;
		let a2 = revers(f1a, f0);
		if (f1a.length % 2 === 0) a2[0] ^= 1;
		f0a = f1a;
		f1a = f1a.concat(a2);
	}
	let array = [];
	for (let i = 0; i < Math.floor(f1a.length / 2); i++)
		array[i] = f1a[i * 2];
	return array;
}
```

These constructions reproduce the symbolic edges of Fibonacci-based patterns and may be interpreted as recursive encoding schemes.

<details><summary>Toward Generalization</summary>

---

While the above generators are constructed specifically for Fibonacci-sized rectangles, preliminary experiments suggest that similar structures may emerge for other co-prime pairs. These systems may obey different symbolic transformation rules, but exhibit comparable recursive or compressible traits. A formal generalization of these behaviors remains an open area of exploration.

---

</details>
